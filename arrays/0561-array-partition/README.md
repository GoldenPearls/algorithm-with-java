# 📘 🔹 \[561] Array Partition

* **문제 링크:** [LeetCode 561. Array Partition](https://leetcode.com/problems/array-partition/description/)

> 각 쌍의 최소값의 합을 최대화하기 위해 요소를 쌍으로 묶을 때, 최적의 전략은 **가장 작은 숫자들을 인접하게 묶는 것**입니다.
> 이렇게 하면 큰 숫자를 최소값으로 “낭비”하지 않게 됩니다.

---

## 🥇 최초 접근 (Solution.java)

### **힌트 기반 아이디어**

* 1차 힌트: “오름차순으로 정렬한 뒤, 인접한 두 개씩 묶고 각 쌍의 첫 번째 원소들만 전부 더해봐.”
* 2차 힌트: "정렬 후 짝수 인덱스 값들을 더한 합을 그대로 반환하면 돼."

---

### **풀이 요약**

1. 배열을 오름차순으로 정렬한다.
2. 인접한 두 개씩 `(nums[0], nums[1])`, `(nums[2], nums[3])` … 묶는다.
3. 각 쌍의 최소값은 항상 짝의 **앞 원소(짝수 인덱스)** 이므로 → 짝수 인덱스 원소를 전부 합한다.

---

### **Java 코드**

```java
import java.util.Arrays;

class Solution {
    public int arrayPairSum(int[] nums) {
        Arrays.sort(nums); // 오름차순 정렬
        int sum = 0;
        for (int i = 0; i < nums.length; i += 2) {
            sum += nums[i]; // 짝수 인덱스 값 더하기
        }
        return sum;
    }
}
```

---

### **예제 입출력**

```text
Input: nums = [1,4,3,2]
Output: 4
설명: (1,2), (3,4) 로 묶으면 min(1,2)+min(3,4)=1+3=4 → 최대값

Input: nums = [6,2,6,5,1,2]
Output: 9
설명: (1,2), (2,5), (6,6) → 1+2+6=9
```

---

### **복잡도**

* **시간복잡도:** `O(n log n)` (정렬)
* **공간복잡도:** `O(log n)` (정렬 과정에서의 스택 메모리)

---
####🔎 QuickSort 시간 복잡도 분석

1. 분할 과정 (Partition)

* 배열에서 pivot을 기준으로 **작은 값 / 큰 값** 으로 나눔.
* 이때 배열의 **모든 원소를 한 번씩 비교**해야 해요.
* 즉, **한 번 분할하는 데 O(n)** 시간이 걸립니다.

2. 재귀 호출 (Divide & Conquer)

* 배열이 반씩 쪼개진다고 가정하면 → 높이가 `log n` 인 **재귀 트리**가 생깁니다.
* 각 레벨에서 처리하는 원소 개수는 `n` 개로 동일합니다.

📌 예시: `n = 8`일 때

```
Level 1 (루트):     8개 처리  → O(8)
Level 2:           4+4개 처리 → O(8)
Level 3:         2+2+2+2개   → O(8)
Level 4 (리프):  1+1+1+...   → O(8)
```

➡ 각 레벨의 총 연산량은 항상 O(n).
➡ 레벨은 최대 log n.

3. 총 시간

* 한 레벨 = O(n)
* 레벨 개수 = O(log n)
* 따라서 전체 = **O(n log n)**

**📊 직관 그림 (QuickSort 시간 복잡도 트리)**

```
         n          ← 전체 n개 비교
       /   \
     n/2   n/2      ← 총합 n
    / \    / \
  n/4 n/4 n/4 n/4   ← 총합 n
  ... 계속 ...
  최종 log n 단계
```

👉 각 단계에서 **총 비교 연산량이 n으로 유지**되기 때문에, 깊이가 log n이므로 `n * log n` 이 되는 거예요.


**🚨 예외: 최악의 경우**

* Pivot이 매번 한쪽 끝값으로만 잡히면 → 매번 `n-1` vs `1` 분할
* 트리 깊이가 `n`이 되어 총 시간은 `O(n^2)`
* 하지만 **Dual-Pivot QuickSort** 같은 구현은 보통 랜덤/중간 pivot을 써서 평균적으로 `O(n log n)`을 유지합니다.


---
### 공간 복잡도에 대한 계산 방법
1. **입력 자체는 제외**

   * `nums` 배열은 이미 주어진 입력 → 공간 복잡도 계산에서는 보통 제외합니다.
   * 즉, **추가로 쓰는 메모리**만 고려해요.

2. **코드 분석하기**

   ```java
   Arrays.sort(nums);
   int sum = 0;
   for (int i = 0; i < nums.length; i += 2) {
       sum += nums[i];
   }
   return sum;
   ```

   * `sum` → 정수형 변수 하나 (O(1))
   * `i` → 반복문 변수 하나 (O(1))
   * 정렬에서 쓰이는 추가 메모리 → **정렬 알고리즘 구현 방식에 따라 다름**

3. **정렬 알고리즘에 따른 차이**
   * 자바의 `Arrays.sort(int[])` 는 **Dual-Pivot QuickSort** 를 사용해요.

     * 최악의 경우 재귀 깊이에 따라 `O(log n)` 스택 공간 사용.
   * 만약 `Arrays.sort(Object[])` 였다면 **TimSort** 를 써서 `O(n)` 보조 배열 공간이 필요할 수도 있음.
  
---

### 추가 정리 🔎 자바 `Arrays.sort(int[])` 내부 동작

* **Dual-Pivot QuickSort** 를 사용합니다.
* QuickSort는 **분할 정복(divide & conquer)** 알고리즘이에요.

> 👉 핵심 아이디어:
1. 배열에서 기준점(피벗)을 정한다.
2. 피벗보다 작은 값들은 왼쪽, 큰 값들은 오른쪽으로 분할한다.
3. 왼쪽 부분과 오른쪽 부분을 다시 **재귀적으로 정렬**한다.

**📊 재귀 호출 구조**

배열 크기 `n = 8`인 경우를 생각해볼게요.

```
정렬([1,4,3,2,  7,6,5,8])
 ├─ 정렬([1,2,3,4])   // 왼쪽
 │   ├─ 정렬([1,2])   // 더 쪼갬
 │   └─ 정렬([3,4])   
 └─ 정렬([5,6,7,8])   // 오른쪽
     ├─ 정렬([5,6])
     └─ 정렬([7,8])
```

**각 단계에서 스택 프레임이 쌓임**
<img width="1639" height="1286" alt="output" src="https://github.com/user-attachments/assets/9879ed32-2b02-4d92-93a9-f3f3f0dacac4" />

* QuickSort는 재귀적으로 불리니까, 호출할 때마다 “현재 구간의 시작/끝 인덱스” 같은 정보가 **스택에 저장**돼요.
* 배열을 반씩 나눈다고 하면 → 재귀 깊이는 `log n` 단계까지 내려감.

* 한 레벨 = O(n)
* 레벨 개수 = O(log n)

> 따라서 전체 = O(n log n)

#### 공간 복잡도 계산

* 각 재귀 호출에서 스택 프레임 하나 차지 → `O(1)`
* 재귀 깊이가 최대 `log n` → **총 O(log n)**

총 공간 = O(log n) + O(1) = O(log n + 1) = O(log n)  // 마지막에 상수항

> 이렇게 **깊이만큼만 스택 공간이 필요**하기 때문에 O(log n)이에요.

---

### **Edge Cases**

* `n = 1`일 때 → 그냥 두 수 중 작은 수가 답.
* `nums`가 음수 포함해도 정렬 후 짝수 인덱스 합을 구하면 정답.

---

### **왜 정렬이 최적인가?**

* 큰 수가 작은 수와 짝지어지면, 그 큰 수는 최소값 계산에서 **무시**된다.
* 따라서 큰 수를 낭비하지 않으려면 → **비슷한 크기끼리 묶는 게 최적**.
* 정렬 후 인접한 원소를 묶으면 이 전략을 자동으로 만족한다.

---

### **추가 Tip**

* 각 쌍에서 **큰 수는 항상 버려진다.**
* 큰 수가 작은 수보다 1 크든 1000 크든, `min`은 결국 작은 수이므로 동일하다.
* 따라서 작은 수를 최대한 살리는 전략 → **짝수 인덱스 합**.

